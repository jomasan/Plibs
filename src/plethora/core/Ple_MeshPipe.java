package plethora.core;

import java.io.OutputStream;
import java.util.ArrayList;

import processing.core.PApplet;
import toxi.geom.*;
import toxi.geom.mesh.*;

/**
 * This is a mesh class to generate cylinders or pipes of vector arrays. 
 * The class allows to work with different polygonal profiles determining the resulution of the mesh.
 * It also allows for the Mesh export into STL files.
 * Written my Jose Sanchez - 2013
 * for feedback please contact me at: jomasan@gmail.com
 * 
 * @author jomasan 
 *
 */


public class Ple_MeshPipe {

	public TriangleMesh mesh;
	public Vec3D verts [];
	//int rows = 0;
	private PApplet p5;

	/**
	 * 
	 * Basic constructor. Provide the PApplet refernce. (type 'this').
	 * The Mesh doen't have a specific location, its location is based on points generated by the internal methods.
	 * 
	 * @param _p5
	 */
	public Ple_MeshPipe(PApplet _p5) {
		mesh = new TriangleMesh();
		p5 = _p5;
	}


	/**
	 * Basic Mesh Pipe Method to create cylinder between 2 points
	 * @param v1 - start point
	 * @param v2 - end point
	 * @param numSegments - segments of the profile
	 * @param radius - radius of the pipe
	 */
	public void createPipe(Vec3D v1, Vec3D v2, int numSegments, float radius) {
		Vec3D [] pts = createVerts(v1, v2, numSegments, radius, radius);
		createFaces3(2, numSegments, pts);
		capEnds(v1, v2, numSegments, pts);
	}

	/**
	 * Basic Mesh Pipe Method to create cylinder between 2 points with 2 different radius
	 * @param v1 - start point
	 * @param v2 - end point
	 * @param numSegments - segments of the profile
	 * @param radius1 - starting radius of the pipe
	 * @param radius2 - ending radius of the pipe
	 */
	public void createPipe(Vec3D v1, Vec3D v2, int numSegments, float radius1, float radius2) {
		Vec3D [] pts = createVerts(v1, v2, numSegments, radius1, radius2);
		createFaces3(2, numSegments, pts);
		capEnds(v1, v2, numSegments, pts);
	}
	/**
	 * Basic Mesh Pipe Method to create cylindric profile on Vector list.
	 * @param ptList - Arraylist of Vectors (Vec3D) to pipe
	 * @param numSegments - segments of the profile
	 * @param radius -  radius of the pipe
	 */
	public void createListPipe(ArrayList <Vec3D> ptList, int numSegments, float radius1 ) {
		Vec3D [] pts = createVerts(ptList, numSegments, radius1);
		createFaces2(ptList.size(), numSegments, pts);

		Vec3D v1 = (Vec3D) ptList.get(0);
		Vec3D v2 = (Vec3D) ptList.get(ptList.size()-1);
		capEnds(v1, v2, numSegments, pts);
	}
	/**
	 * Allows to export mesh, mesh must have been previously generated by some of the pipe methods
	 * @param name - name of the file to generate
	 */
	public void exportToSTL(String name){
		//String fileID = name+(System.currentTimeMillis()/1000);
		//FileOutputStream fs=new FileOutputStream(sketchPath(fileID+".stl"));

		OutputStream os = p5.createOutput(name);
		mesh.saveAsSTL(os);
	}
	/**
	 * Clears the Mesh instance of the class. Useful for dynamically updating the mesh generated.
	 */
	public void resetMesh(){
		mesh.clear();
	}

	/**
	 * Basic Mesh Pipe Method to create cylinder between 2 points with 2 different radius, Returns the TriangleMesh Instance.
	 * @param v1 - start point
	 * @param v2 - end point
	 * @param numSegments - segments of the profile
	 * @param radius1 - starting radius of the pipe
	 * @param radius2 - ending radius of the pipe
	 */
	public TriangleMesh createPipeMesh( Vec3D v1, Vec3D v2, int numSegments, float radius1, float radius2) {

		TriangleMesh m = new TriangleMesh();

		Vec3D [] pts = createVerts(v1, v2, numSegments, radius1, radius2);
		createFaces4(2, numSegments, pts, m);
		capEnds(v1, v2, numSegments, pts);

		return m;
	}
	
	/**
	 * Get TriangleMesh instance 
	 */
	public TriangleMesh getMesh(){
		return mesh;
	}
	/**
	 * Get Vec3D array from points generated in create Vertices method.
	 */
	public Vec3D [] getPoints(){
		return verts;
	}
	
	/**
	 * Loops through the mesh and draws the triangles using beginShape method from processing.
	 * @param myMesh - Mesh instance to be rendered
	 * @param smooth - Smooth on/off.
	 */
	public void drawMesh(TriangleMesh myMesh, boolean smooth) {
		p5.beginShape(p5.TRIANGLES);
		if (smooth) {
			for (Face f : myMesh.getFaces()) {
				p5.normal(f.a.normal.x, f.a.normal.y, f.a.normal.z);
				p5.vertex(f.a.x, f.a.y, f.a.z);
				p5.normal(f.b.normal.x, f.b.normal.y, f.b.normal.z);
				p5.vertex(f.b.x, f.b.y, f.b.z);
				p5.normal(f.c.normal.x, f.c.normal.y, f.c.normal.z);
				p5.vertex(f.c.x, f.c.y, f.c.z);
			}
		} 
		else {
			for (Face f : myMesh.getFaces()) {
				p5.normal(f.normal.x, f.normal.y, f.normal.z);
				p5.vertex(f.a.x, f.a.y, f.a.z);
				p5.vertex(f.b.x, f.b.y, f.b.z);
				p5.vertex(f.c.x, f.c.y, f.c.z);
			}
		}
		p5.endShape();
	}
	/**
	 * Internal method to cap the ends of a mesh pipe between 2 vectors, use in sequence: createVerts, createFaces, capEnds
	 * @param v1 - Vector 1
	 * @param v2 - Vector 2
	 * @param numSegments - Number of segments for the profile
	 * @param pts - Point array
	 */
	public void capEnds(Vec3D v1, Vec3D v2, int numSegments, Vec3D [] pts) {

		for (int j = 0; j < numSegments-1; j++) {   
			//CAP 1
			if (j < numSegments-2) {
				Vec3D pt1 = pts[j  ];
				Vec3D pt2 = pts[j + 1 ];
				Vec3D pt3 = v1;
				mesh.addFace(pt1, pt2, pt3);
			}
			else {
				Vec3D pt1 = pts[j  ];
				Vec3D pt2 = pts[0 ];
				Vec3D pt3 = v1;
				mesh.addFace(pt1, pt2, pt3);
			}
		}

		for (int j = 0; j < numSegments-1; j++) {      
			//CAP 1
			if (j < numSegments-2) {
				Vec3D pt1 = pts[pts.length - j - 1 ];
				Vec3D pt2 = pts[pts.length - j - 2 ];
				Vec3D pt3 = v2;
				mesh.addFace(pt1, pt2, pt3);
			}
			else {
				Vec3D pt1 = pts[pts.length - j - 1  ];
				Vec3D pt2 = pts[pts.length - 1 ];
				Vec3D pt3 = v2;
				mesh.addFace(pt1, pt2, pt3);
			}
		}
	}

	/**
	 * creates the faces of the mesh, use in sequence: createVerts, createFaces, capEnds
	 * @param segX - number of columns 
	 * @param segY - number of rows
	 * @param pts - Point array
	 */
	public void createFaces3(int segX, int segY, Vec3D [] pts) {
		//mesh.clear();

		for (int i = 0; i < segX-1; i++) {
			for (int j = 0; j < segY-1; j++) {

				if (j < segY-2) {
					Vec3D pt1 = pts[j + (segY*i) ];
					Vec3D pt2 = pts[j + 1 + (segY*i)];
					Vec3D pt3 = pts[j + (segY-1) + (segY*i)];
					Vec3D pt4 = pts[j + 1 + (segY-1) + (segY*i)];

					mesh.addFace(pt1, pt2, pt3);
					mesh.addFace(pt4, pt3, pt2);
				}
				else {

					Vec3D pt1 = verts[j + (segY*i) ];
					Vec3D pt2 = verts[0 + (segY*i)];
					Vec3D pt3 = verts[j + (segY-1) + (segY*i)];
					Vec3D pt4 = verts[0 + (segY-1) + (segY*i)];

					mesh.addFace(pt1, pt2, pt3);
					mesh.addFace(pt4, pt3, pt2);
				}
			}
		}
	}
	/**
	 * creates the faces of the mesh, variation, use in sequence: createVerts, createFaces, capEnds
	 * @param segX - number of columns 
	 * @param segY - number of rows
	 * @param pts - Point array
	 * @param m - specific mesh instance to add the new faces to.
	 */
	public void createFaces4(int segX, int segY, Vec3D [] pts, TriangleMesh m) {
		//mesh.clear();

		for (int i = 0; i < segX-1; i++) {
			for (int j = 0; j < segY-1; j++) {

				if (j < segY-2) {
					Vec3D pt1 = pts[j + (segY*i) ];
					Vec3D pt2 = pts[j + 1 + (segY*i)];
					Vec3D pt3 = pts[j + (segY-1) + (segY*i)];
					Vec3D pt4 = pts[j + 1 + (segY-1) + (segY*i)];

					mesh.addFace(pt1, pt2, pt3);
					mesh.addFace(pt4, pt3, pt2);
				}
				else {

					Vec3D pt1 = verts[j + (segY*i) ];
					Vec3D pt2 = verts[0 + (segY*i)];
					Vec3D pt3 = verts[j + (segY-1) + (segY*i)];
					Vec3D pt4 = verts[0 + (segY-1) + (segY*i)];

					m.addFace(pt1, pt2, pt3);
					m.addFace(pt4, pt3, pt2);
				}
			}
		}
	}
	/**
	 * Simple vector line shortcut for debugging
	 * @param v1 - vector 1
	 * @param v2 - vector 2
	 */
	public void vLine(Vec3D v1, Vec3D v2) {
		p5.line(v1.x, v1.y, v1.z, v2.x, v2.y, v2.z);
	}
	
	/**
	 * main method to generate a vector array of the pipe vertices with varying radius
	 * @param v1 - start point
	 * @param v2 - end point
	 * @param numSegments - number of segments in the profile
	 * @param radius - starting radius
	 * @param radius2 - ending radius
	 */
	public Vec3D [] createVerts(Vec3D v1, Vec3D v2, int numSegments, float radius, float radius2) {

		int vCount = 0;
		verts = new Vec3D[2 * (numSegments-1)];

		Vec3D n = v1.cross(v2);         //Vector3.Cross(points[j], points[j+1]);
		n.normalize();
		Vec3D dir = v2.sub(v1);
		dir.normalize();
		Vec3D wid = n.cross(dir);
		wid.normalize();

		for (int j = 0; j < 2; j++) { 
			for (int i = 0; i < numSegments-1; i++) {
				Vec3D widCopy = wid.copy();
				widCopy.normalize();
				float angle = (p5.TWO_PI / (numSegments - 1.0f)) * i;
				Vec3D ppt = rotateAroundAxis(widCopy, dir, angle);
				ppt.normalize();


				if (j ==0) {
					ppt.scaleSelf(radius);
					ppt.addSelf(v1);
				}
				else {
					ppt.scaleSelf(radius2);
					ppt.addSelf(v2);
				}
				verts[vCount] = ppt; 
				vCount++;
				//println(vCount);
			}
		}
		///println("exit:" + vCount);
		return verts;
	}
	/**
	 * main method to generate a vector array of the pipe vertices.
	 * @param v1 - start point
	 * @param v2 - end point
	 * @param numSegments - number of segments in the profile
	 * @param radius - pipe radius
	 */
	public Vec3D []  createVerts(ArrayList <Vec3D> pts, int numSegments, float radius1) {

		//rows = pts.size();
		int numPts = pts.size();
		//println((numPts-1) * (segments-1));
		//ArrayList newPts = new ArrayList();
		verts = new Vec3D[numPts * numSegments];

		int vCount2 = 0;
		int tCount = 0;

		for (int j = 0 ; j < numPts-1 ; j++ ) {
			Vec3D pt1 = (Vec3D) pts.get(j);
			Vec3D pt2 = (Vec3D) pts.get(j+1);

			Vec3D pt1f = pt1.add(new Vec3D(10000, 10000, 10000));
			Vec3D pt2f = pt2.add(new Vec3D(10000, 10000, 10000));

			Vec3D n = pt1f.cross(pt2f);         //Vector3.Cross(points[j], points[j+1]);
			n.normalize();
			Vec3D dir = pt2f.sub(pt1f);
			dir.normalize();
			Vec3D wid = n.cross(dir);
			wid.normalize();

			//Vec3D widPlus = wid.add(pt1);
			for (int i = 0; i < numSegments; i++) {
				Vec3D widCopy = wid.copy();
				widCopy.normalize();
				float angle = (p5.TWO_PI / (numSegments - 1.0f)) * i;
				Vec3D ppt = rotateAroundAxis(widCopy, dir, angle);
				ppt.normalize();
				Vec3D nooMal = ppt.copy();
				ppt.scaleSelf(radius1);
				ppt.addSelf(pt1);


				verts[vCount2] = ppt;
				vCount2++;
			}
			//last point:-------------------------------------------------------------------------//NOT WORKING YET...
			if (j == pts.size()-2) {
				Vec3D ptx = (Vec3D) pts.get(pts.size()-1);
				Vec3D ptx2 = (Vec3D) pts.get(pts.size()-2);

				Vec3D ptxf = ptx.add(new Vec3D(10000, 10000, 10000));
				Vec3D ptx2f = ptx2.add(new Vec3D(10000, 10000, 10000));

				Vec3D n2 = ptxf.cross(ptx2f);
				n2.normalize();
				Vec3D dir2  = ptx2f.sub(ptxf);
				dir2.normalize();
				Vec3D wid2  = n2.cross(dir2);
				wid2.normalize();

				for (int q = 0 ; q < numSegments ; q++ ) {
					Vec3D widCopy2 = wid2.copy();
					widCopy2.normalize();

					float angle2 = (p5.TWO_PI / (numSegments-1)) * q;
					Vec3D ppt2  = rotateAroundAxis(widCopy2, dir2, -angle2);
					ppt2.normalize();
					Vec3D nooMal2  = ppt2.copy(); // make a copy of the normal:
					ppt2.scaleSelf(radius1);
					ppt2.addSelf(pt2);

					verts[vCount2] = ppt2;
					vCount2++;
				}
			}
			//last point
		}

		return verts;
	}
	/**
	 * creates the faces of the mesh, variation, use in sequence: createVerts, createFaces, capEnds
	 * @param segX - number of columns 
	 * @param segY - number of rows
	 * @param pts - Point array
	 */
	public void createFaces2(int segX, int segY, Vec3D [] pts) {

		int tCount = 0;
		//mesh.clear();
		//println(rows);
		//println(segments);

		for (int i = 0; i < segX-1; i++) {
			for (int j = 0; j < segY-1; j++) {

				Vec3D pt1 = pts[j + (segY*i) ];
				Vec3D pt2 = pts[j + 1 + (segY*i)];
				Vec3D pt3 = pts[j + segY + (segY*i)];
				Vec3D pt4 = pts[j + 1 + segY + (segY*i)];

				mesh.addFace(pt1, pt2, pt3);
				mesh.addFace(pt4, pt3, pt2);
			}
		}
	}
	/**
	 * draws points of the pipe, they must have been generated first
	 */
	public void drawVerts() {

		//println("verts:" + verts.length);
		for (int i = 0; i < verts.length; i++) {
			p5.point(verts[i].x, verts[i].y, verts[i].z);
		}
		//for (Vec3D p : verts2) {
		// p5.point(p.x, p.y, p.z);
		//}
	}
	/**
	 * Alows to do vector rotation around vectorial axis.
	 * @param v - vector to rotate
	 * @param axis - axis of rotation
	 * @param theta - angle of rotation
	 */
	public Vec3D rotateAroundAxis(Vec3D v, Vec3D axis, float theta) {
		Vec3D result  = new Vec3D (0, 0, 0);

		float ax = axis.x;
		float ay = axis.y;
		float az = axis.z;

		float ux = ax * v.x;
		float uy = ax * v.y;
		float uz = ax * v.z;

		float vx = ay * v.x;
		float vy = ay * v.y;
		float vz = ay * v.z;

		float wx = az * v.x;
		float wy = az * v.y;
		float wz = az * v.z;

		float si  = p5.sin(theta);
		float co   = p5.cos(theta);

		float xx  = (ax * (ux + vy + wz)
				+ (v.x * (ay * ay + az * az) - ax * (vy + wz)) * co + (-wy + vz)
				* si);
		float yy  =  (ay * (ux + vy + wz)
				+ (v.y * (ax * ax + az * az) - ay * (ux + wz)) * co + (wx - uz)
				* si);
		float zz  = (az * (ux + vy + wz)
				+ (v.z * (ax * ax + ay * ay) - az * (ux + vy)) * co + (-vx + uy)
				* si);

		result.x = xx; 
		result.y = yy; 
		result.z = zz;        

		return result;
	}
}

